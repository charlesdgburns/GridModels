"""This module calculates the animal centroid position from DeepLabCut tracking data."""
# %% Imports
import numpy as np
import pylab as plt
import networkx as nx
from ..maze import representations as maze_reps


# %% Main function
def get_centroid_positions(bodypart_positions):
    """Returns an array of centroid positions in x,y coords(m) from a bodypart_positions array generated by the
    get_dlc_positions_array() function in dlc_preprocessing.py and a binary array which indicates which positions were interpolated.
    """
    raw_centroid_positions = np.array([get_raw_centroid_position(frame) for frame in bodypart_positions])
    clean_centroid_positions = get_cleaned_centroid_positions(raw_centroid_positions)
    interpolated_centroid_positions = interpolate_centroid_position_nans(clean_centroid_positions)
    interpolated_xy = np.isnan(clean_centroid_positions).astype(int)
    interpolated_binary = np.logical_or(interpolated_xy[:, 0], interpolated_xy[:, 1]).astype(int)
    return interpolated_centroid_positions, interpolated_binary


# %% Subfunctions
def get_raw_centroid_position(positions):
    """Get the centroid position of the body, using the head_back position if available, otherwise the body_front position
    Input: dlc_positions array generated by get_dlc_positions_array() in dlc_preprocessing.py"""
    head_back = positions[2]
    if not np.isnan(head_back).any():
        return head_back
    else:
        body_front = positions[5]
        if not np.isnan(body_front).any():
            return body_front
        else:
            return (np.nan, np.nan)


def get_cleaned_centroid_positions(body_centroids, pos_change_threshold=0.03):
    """Clean body centroid position data by removing jumps in position that are larger than the set threshold.
    Note: threshold informed by looking at the distribution of next point distances in the data."""
    cleaned_coords = []
    for i in [body_centroids[:, 0], body_centroids[:, 1]]:
        forward_diff = np.diff(i, prepend=i[0])
        backward_diff = np.flip(np.diff(np.flip(i), prepend=i[-1]))
        single_jump_mask = np.logical_and(
            np.abs(forward_diff) > pos_change_threshold, np.abs(backward_diff) > pos_change_threshold
        )
        jump_nan_mask = np.logical_and(np.abs(backward_diff) > pos_change_threshold, np.isnan(forward_diff))
        nan_jump_mask = np.logical_and(np.abs(forward_diff) > pos_change_threshold, np.isnan(backward_diff))
        combined_mask = np.logical_or(np.logical_or(single_jump_mask, jump_nan_mask), nan_jump_mask)
        i[combined_mask] = np.nan
        cleaned_coords.append(i)
    clean_body_position = np.array(cleaned_coords).T
    nan_mask = np.isnan(clean_body_position)
    single_nan_mask = np.logical_xor(
        nan_mask[:, 0], nan_mask[:, 1]
    )  # Identify tuples with one NaN value and one non-NaN value
    clean_body_position[single_nan_mask] = np.nan
    return clean_body_position


def interpolate_centroid_position_nans(body_centroids):
    """Interpolate (linear) NaN values in body centroid position data."""
    centroids = body_centroids.copy()
    x = centroids[:, 0]
    y = centroids[:, 1]
    non_nan_indices_x = np.where(~np.isnan(x))[0]
    non_nan_indices_y = np.where(~np.isnan(y))[0]
    non_nan_values_x = x[non_nan_indices_x]
    non_nan_values_y = y[non_nan_indices_y]
    x_interpolated = np.interp(np.arange(len(x)), non_nan_indices_x, non_nan_values_x)
    y_interpolated = np.interp(np.arange(len(y)), non_nan_indices_y, non_nan_values_y)
    return np.array([x_interpolated, y_interpolated]).T


# %% Get centroi position from dlc_data


# %% Quality control functions
def plot_body_centroid_positions(body_centroids, show_interpolated=True):
    """Plot the x and y coordinates of the body centroid over time, with interpolated values shown in red."""
    centroids = body_centroids.copy()
    nan_positions = np.isnan(centroids)
    interp_centroids = interpolate_centroid_position_nans(centroids)
    x = np.arange(len(interp_centroids))
    if show_interpolated:
        plt.plot(
            x[~nan_positions[:, 0]],
            interp_centroids[~nan_positions[:, 0], 0],
            "bo",
            label="Original x-data",
            markersize=3,
        )
        plt.plot(
            x[nan_positions[:, 0]],
            interp_centroids[nan_positions[:, 0], 0],
            "ro",
            label="Interpolated x-values",
            markersize=3,
        )
        plt.plot(
            x[~nan_positions[:, 1]],
            interp_centroids[~nan_positions[:, 1], 1],
            "go",
            label="Original y-data",
            markersize=3,
        )
        plt.plot(
            x[nan_positions[:, 1]],
            interp_centroids[nan_positions[:, 1], 1],
            "yo",
            label="Interpolated y-values",
            markersize=3,
        )
    else:
        plt.plot(x, interp_centroids[:, 0], "b-", label="Original x-data")
        plt.plot(x, interp_centroids[:, 1], "g-", label="Original y-data")
    plt.xlabel("Frames")
    plt.ylabel("x/y position (m)")
    plt.legend()


# %% QC
if __name__ == "__main__":
    from preprocessing.get_sessions_data_directory import get_data_directory_df
    from preprocessing.get_trajectories_df import get_frames_df

    SESSIONS_DATA_DIRECTORY_DF = get_data_directory_df()

    def plot_maze_trajectories_qc(SESSION_DATA_DIRECTORY_DF):
        """Plot the trajectory of the animal through the maze, if the trajectory is valid."""
        first_session = SESSION_DATA_DIRECTORY_DF.iloc[np.argmin(SESSION_DATA_DIRECTORY_DF["datetime"])]
        last_session = SESSION_DATA_DIRECTORY_DF.iloc[np.argmax(SESSION_DATA_DIRECTORY_DF["datetime"])]
        f, ax = plt.subplots(1, 2, figsize=(10, 5), clear=True)
        for i, session in enumerate([first_session, last_session]):
            maze = maze_reps.simple_maze(session.maze_structure)
            frames_df = get_frames_df(session)
            centroid_positions = frames_df["centroid_position"][["x", "y"]].to_numpy()
            ax[i].plot(centroid_positions.T[0], centroid_positions.T[1], color="red", alpha=0.5)
            ax[i].set_title(f"Session Trajectory - Exp Day {session.experimental_day}")
            nx.draw(maze, pos=maze.nodes(data="position"), node_size=15, node_color="black", ax=ax[i])
