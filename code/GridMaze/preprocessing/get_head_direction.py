"""This module calculates the head direction from DeepLabCut tracking data."""
#%% Imports
import numpy as np
import pylab as plt
from scipy.stats import circmean

#%% Main function
def get_head_direction(bodypart_positions):
    """Returns an array of head direction values in degrees (0-360 from true north) from a bodypart_positions array generated by the 
    get_dlc_positions_array() function in dlc_preprocessing.py and a binary array which indicates where directions were interpolated."""
    raw_head_direction = np.array([get_raw_head_direction(position) for position in bodypart_positions])
    clean_head_direction = get_cleaned_head_direction(raw_head_direction)
    interpolated_head_direction = interpolate_head_direction_nans(clean_head_direction)
    return interpolated_head_direction, np.isnan(clean_head_direction).astype(int)

#%% Subfunctions
def interpolate_head_direction_nans(data):
    """Interpolate NaN values in a numpy array of angular data using linear interpolation in 2D polar coordinates."""
    non_nan_indices = np.where(~np.isnan(data))[0]
    non_nan_values = data[non_nan_indices]
    # Convert angles to 2D polar representation
    x = np.cos(np.deg2rad(non_nan_values))
    y = np.sin(np.deg2rad(non_nan_values))
    x_interpolated = np.interp(np.arange(len(data)), non_nan_indices, x)
    y_interpolated = np.interp(np.arange(len(data)), non_nan_indices, y)
    # Convert interpolated x and y polar coords back to angles
    interpolated_angles = np.rad2deg(np.arctan2(y_interpolated, x_interpolated)) % 360
    return interpolated_angles

def get_cleaned_head_direction(head_direction, high=360, low=0, circdiff_threshold=50):
    """Clean the head direction data by identifying and removing sudden jumps or discontinuities.
    The function processes a numpy array of angular head direction values, detects any sudden jumps or
    discontinuities that exceed the circdiff_threshold, and replaces them with NaN."""
    thetas = head_direction.copy()
    forward_circdiff = (np.diff(thetas, prepend=thetas[0]) + high/2) % high - high/2
    backward_circdiff = np.flip((np.diff(np.flip(thetas), prepend=thetas[-1]) + high/2) % high - high/2)
    single_jump_mask = np.logical_and(np.abs(forward_circdiff) > circdiff_threshold, np.abs(backward_circdiff) > circdiff_threshold)
    jump_nan_mask = np.logical_and(np.abs(backward_circdiff) > circdiff_threshold, np.isnan(forward_circdiff))
    nan_jump_mask = np.logical_and(np.abs(forward_circdiff) > circdiff_threshold, np.isnan(backward_circdiff))
    combined_mask = np.logical_or(np.logical_or(single_jump_mask, jump_nan_mask), nan_jump_mask)
    thetas[combined_mask] = np.nan
    return thetas
 
def get_raw_head_direction(bodypart_positions):
    """Returns the angle in degrees of the direction the head is facing.
    Input: dlc_positions array generated by get_dlc_positions_array() in dlc_preprocessing.py"""
    head_front, head_mid, head_back, ear_L, ear_R = bodypart_positions[:5]
    if not np.isnan(head_front).all():
        front = head_front
    elif not np.isnan(head_mid).all():
        front = head_mid
    else:
        front = np.array([np.nan, np.nan])
    if not np.isnan(head_back).all():
        back = head_back
    elif not np.isnan(ear_L).all() and not np.isnan(ear_R).all():
        back = (ear_L + ear_R)/2
    else:
        back = np.array([np.nan, np.nan])
    if not np.isnan(front).all() or not np.isnan(back).all():
        theta1 = _get_front_facing_direction(back, front)
    else:
        theta1 = np.nan
    if not np.isnan(ear_L).all() or not np.isnan(ear_R).all():
        theta2 = _get_front_facing_direction_from_ears(ear_L, ear_R)
    else:
        theta2 = np.nan
    valid_thetas = [theta for theta in [theta1, theta2] if not np.isnan(theta)]
    if len(valid_thetas) == 0:
        return np.nan
    else:
        av_theta = circmean(valid_thetas, high=2*np.pi, low=0)
        return np.rad2deg(av_theta)


def _get_front_facing_direction(front_point, back_point):
    """Returns the angle in radians of the direction the head is facing,
    measured clockwise from true north as the direction from the back of the 
    head to the front of the head."""
    dx, dy = back_point - front_point
    angle_rad = np.arctan2(dx, dy)
    angle_rad = (angle_rad + 2*np.pi) % (2*np.pi)  # adjust so that true north is 0 radians
    return angle_rad

def _get_front_facing_direction_from_ears(left_point, right_point):
    """Returns the angle in radians of the direction the head is facing,
    measured clockwise from true north as the direction pi/2 radians clockwise from
    the direction from the right ear to the left ear."""
    dx, dy = right_point - left_point
    angle_rad = np.arctan2(dx, dy)
    angle_rad = (angle_rad + 2*np.pi) % (2*np.pi)  # adjust so that true north is 0 radians
    perp_angle_rad = angle_rad - np.pi/2 #clockwise 90 degrees is front facing
    return perp_angle_rad

#%% Quality control functions

def estimate_interpolation_error(data, padding_size=1):
    """Estimate the interpolation error of a list of subsequences by calculating the median root mean squared error
    of non-nan angular direction data in a nan_containing angular direction data array."""
    subsequences = _find_equivalent_non_nan_subsequences(data)
    mses = []
    for subsequence in subsequences:
        data_range = np.max(subsequence) - np.min(subsequence)
        if data_range == 0:
            continue
        true_middle = subsequence[padding_size:-padding_size]
        nan_subsequence = subsequence.copy()
        nan_subsequence[padding_size:-padding_size]=np.nan
        interpolated_subsequence = interpolate_head_direction_nans(nan_subsequence)
        interpolated_middle = interpolated_subsequence[padding_size:-padding_size]
        squared_error = np.square(true_middle - interpolated_middle)
        mse = np.mean(squared_error)
        mses.append(mse)
    return np.median(np.sqrt(np.array(mses)))

def plot_cumulative_diff_head_direction(head_direction, show_interpolated=True):
    """Plot the cumulative difference in head direction over time, with interpolated values shown in red."""
    hd = head_direction.copy()
    hd_circdiff = circdiff(hd)
    nan_positions = np.isnan(hd_circdiff)
    interp_circdiff_hd = circdiff(interpolate_head_direction_nans(hd))
    cumsum_interp_circdiff_hd = np.cumsum(interp_circdiff_hd)
    x = np.arange(len(interp_circdiff_hd))
    if show_interpolated:
        plt.plot(x[~nan_positions], cumsum_interp_circdiff_hd[~nan_positions], 'bo', label='Original data', markersize=3)
        plt.plot(x[nan_positions], cumsum_interp_circdiff_hd[nan_positions], 'ro', label='Interpolated values', markersize=3)
    else:
        plt.plot(x, cumsum_interp_circdiff_hd, 'b-', label='Original data')
    plt.xlabel('Frames')
    plt.ylabel('Cumulative difference in head direction (deg)')
    plt.legend()
    plt.show()

def plot_hist_NaN_runs(a):
    """Plot a histogram of the length of NaN runs in a numpy array."""
    nan_run_lengths = _get_NaN_runs_length(a)/60
    plt.hist(nan_run_lengths, color='grey')
    plt.xlabel('NaN run length (s)')
    plt.ylabel('Count')

def _find_equivalent_non_nan_subsequences(data, padding_size):
    """Find subsequences of a numpy array of non-nan angular direction data that are equivalent to the 
    nan-containg sequences in the original data"""
    subsequences = []
    lengths = _get_NaN_runs_length(data)
    for length in lengths:
        adjusted_length = length + 2 * padding_size
        found = False
        start = 0
        while start < len(data) and not found:
            if not np.isnan(data[start]):
                end = start + 1
                while end < len(data) and not np.isnan(data[end]):
                    end += 1
                if end - start == adjusted_length:
                    subsequences.append(data[start:end])
                    found = True
                else:
                    start += 1
            else:
                start += 1
    return subsequences

def _get_NaN_runs_length(a):
    """Get the length of each NaN run in a numpy array."""
    mask = np.concatenate(([False],np.isnan(a),[False])) # Mask of NaNs
    if ~mask.any():
        return 0
    else:
        # Count of NaNs in each NaN group. Then, get max count as o/p.
        c = np.flatnonzero(mask[1:] < mask[:-1]) - \
            np.flatnonzero(mask[1:] > mask[:-1])
    return c   

def circdiff(theta, high=360, low=0):
    """Difference between two angles, in radians, with the option to specify the high and low values"""
    return (np.diff(theta) + high/2) % high - high/2
#%%